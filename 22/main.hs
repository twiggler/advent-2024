import Data.Bits (shiftL, shiftR, xor)
import Parsing (readLines)
import System.Environment (getArgs)
import Data.HashMap.Strict (HashMap)
import Data.HashMap.Strict qualified as HM
import Data.List.Split (divvy)
import Data.Foldable (foldl')

readCodes :: FilePath -> IO [Int]
readCodes = fmap (fmap read) . readLines

evolve :: Int -> Int
evolve s0 =
  let magic = 16777216
      s1 = (s0 `shiftL` 6 `xor` s0) `mod` magic
      s2 = (s1 `shiftR` 5 `xor` s1) `mod` magic
   in (s2 `shiftL` 11 `xor` s2) `mod` magic

generateSecrets :: Int -> [Int]
generateSecrets = iterate evolve

priceBySequence :: [Int] -> HashMap [Int] Int
priceBySequence secrets =
    let sequenceLength = 4
        prices = (`mod` 10) <$> secrets
        diffs = zipWith (-) (drop 1 prices) prices
        sequences = divvy sequenceLength 1 diffs
        sequencesAssocPrices = sequences `zip` drop sequenceLength prices
    in  HM.fromListWith (const id) sequencesAssocPrices

solve1 :: Int -> [Int] -> Int
solve1 length' = sum . fmap generate
  where
    generate seed = generateSecrets seed !! length'

solve2 :: Int -> [Int] -> Int
solve2 length' seeds =
    let secrets = take (length' + 1) . generateSecrets <$> seeds
        priceMaps = priceBySequence <$> secrets
        -- Possible optimization: use mutable hashmap
        combined = foldl' (HM.unionWith (+)) HM.empty priceMaps
    in  maximum combined

main :: IO ()
main = do
  (filePath : _) <- getArgs
  codes <- readCodes filePath
  let sumOfComplexities = solve1 2000 codes
      maxBananas = solve2 2000 codes
  putStrLn $ "Sum of 2000th secret number generated by each buyer: " ++ show sumOfComplexities
  putStrLn $ "Maximum number of attainable bananas: " ++ show maxBananas
